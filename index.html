<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Device list - AssetFlow IT</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="css/shared.css">
  <link rel="stylesheet" href="css/device-list.css">
  <script src="js/qrcode.min.js"></script>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <div class="header-left">
        <button class="sidebar-toggle" title="Toggle Sidebar">‚ò∞</button>
        <a href="index.html" class="logo">
          <div class="logo-icon">üíª</div>
          <span>AssetFlow IT</span>
        </a>
      </div>
      <div class="header-right">
        <button class="mobile-menu-toggle">‚ò∞</button>
      </div>
    </div>
  </header>

  <div class="sidebar">
    <div class="sidebar-content">
      <div class="sidebar-section">
        <div class="sidebar-section-header">Admin desktop</div>
        <a href="dashboard.html" class="sidebar-item" data-title="Dashboard">
          <i class="fas fa-th-large sidebar-item-icon"></i>
          <span>Dashboard</span>
        </a>
        <a href="index.html" class="sidebar-item active" data-title="Device list">
          <i class="fas fa-box sidebar-item-icon"></i>
          <span>Device List</span>
        </a>
        <a href="import-device.html" class="sidebar-item" data-title="Import device">
          <i class="fas fa-file-import sidebar-item-icon"></i>
          <span>Import Device</span>
        </a>
        <a href="user-list.html" class="sidebar-item" data-title="User list">
          <i class="fas fa-users sidebar-item-icon"></i>
          <span>User List</span>
        </a>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-section-header">Mobile/tablet UI</div>
        <a href="qr-scan.html" class="sidebar-item" data-title="QR scan">
          <i class="fas fa-qrcode sidebar-item-icon"></i>
          <span>QR scan</span>
        </a>
      </div>
    </div>
    
    <div class="sidebar-user-profile">
      <div class="user-profile">
        <div class="user-avatar">JD</div>
        <div class="user-info">
          <span class="user-name">John Doe</span>
          <span class="user-email">johndoe@company.com</span>
        </div>
      </div>
    </div>
  </div>

  <main class="main-content">
    <h1 class="page-title">Device list</h1>
    <!-- Search and Filter Bar -->
    <div class="search-filter-bar">
      <div class="search-input-wrapper">
        <i class="fas fa-search search-icon"></i>
        <input type="text" class="search-input-main" id="searchInput" placeholder="Search by name, asset code, user...">
      </div>
      <div class="custom-dropdown" id="typeCategoryDropdown">
        <button class="custom-dropdown-button" type="button">
          <span class="custom-dropdown-text">All categories</span>
          <i class="fas fa-chevron-down custom-dropdown-icon"></i>
        </button>
        <div class="custom-dropdown-menu">
          <div class="custom-dropdown-option" data-value="">All categories</div>
          <div class="custom-dropdown-option" data-value="IT Equipment">IT equipment</div>
          <div class="custom-dropdown-option" data-value="Software & Licenses">Software & licenses</div>
          <div class="custom-dropdown-option" data-value="Vehicles">Vehicles</div>
          <div class="custom-dropdown-option" data-value="Office Equipment & Furniture">Office equipment & furniture</div>
        </div>
        <select class="filter-dropdown hidden" id="typeCategoryFilter">
          <option value="">All categories</option>
          <option value="IT Equipment">IT equipment</option>
          <option value="Software & Licenses">Software & licenses</option>
          <option value="Vehicles">Vehicles</option>
          <option value="Office Equipment & Furniture">Office equipment & furniture</option>
        </select>
      </div>
      <div class="custom-dropdown" id="typeDropdown">
        <button class="custom-dropdown-button" type="button">
          <span class="custom-dropdown-text">All types</span>
          <i class="fas fa-chevron-down custom-dropdown-icon"></i>
        </button>
        <div class="custom-dropdown-menu">
          <!-- options will be populated dynamically -->
        </div>
        <select class="filter-dropdown hidden" id="typeFilter">
          <option value="">All types</option>
        </select>
      </div>
      <div class="custom-dropdown" id="statusDropdown">
        <button class="custom-dropdown-button" type="button">
          <span class="custom-dropdown-text">All statuses</span>
          <i class="fas fa-chevron-down custom-dropdown-icon"></i>
        </button>
        <div class="custom-dropdown-menu">
          <div class="custom-dropdown-option" data-value="">All statuses</div>
          <div class="custom-dropdown-option" data-value="IN_STOCK">In stock</div>
          <div class="custom-dropdown-option" data-value="IN_USE">In use</div>
          <div class="custom-dropdown-option" data-value="MAINTENANCE">Maintenance</div>
          <div class="custom-dropdown-option" data-value="BROKEN">Broken</div>
        </div>
        <select class="filter-dropdown hidden" id="statusFilter">
          <option value="">All statuses</option>
          <option value="IN_STOCK">In stock</option>
          <option value="IN_USE">In use</option>
          <option value="MAINTENANCE">Maintenance</option>
          <option value="BROKEN">Broken</option>
        </select>
      </div>
      <a href="import-device.html" class="btn-import">
        <i class="fas fa-upload"></i>
        <span>Import</span>
      </a>
      <button class="btn-export" onclick="downloadCSV()">
        <i class="fas fa-download"></i>
        <span>Export</span>
      </button>
    </div>
    
    <!-- Advanced Filters (Hidden by default, can be expanded) -->
    <div class="advanced-filters-collapsed" id="advancedFilters">
      <div class="advanced-filters-content">
        <div class="filter-group">
          <label class="filter-label">Warranty:</label>
          <select class="filter-select-small" id="warrantyFilter">
            <option value="">All</option>
            <option value="valid">Valid Warranty</option>
            <option value="expired">Expired Warranty</option>
          </select>
        </div>
        
        <div class="filter-group">
          <label class="filter-label">Specs Search:</label>
          <input type="text" class="filter-input-small" id="specsFilter" placeholder="e.g. i7, 16GB, 512GB, Intel...">
        </div>
        
        <button class="clear-filters-btn" id="clearFiltersBtn">Clear All</button>
      </div>
    </div>
    
    <div class="toolbar">
      <div class="toolbar-left">
        <a href="add-device.html" class="btn btn-primary">
          <span class="add-icon">+</span>
          <span>Add device</span>
        </a>
      </div>
      <div class="view-toggle">
        <button class="view-btn active" data-view="table" id="tableViewBtn">Table</button>
        <button class="view-btn" data-view="grid" id="gridViewBtn">Grid</button>
      </div>
    </div>
    
    <div class="device-grid" id="deviceGrid"></div>

    <div class="table-controls">
      <div class="table-info">
        <span id="tableInfo">Showing 0 devices</span>
      </div>
      <div class="table-pagination-controls">
        <select class="page-size-select" id="pageSizeSelect">
          <option value="30" selected>30 per page</option>
          <option value="50">50 per page</option>
          <option value="100">100 per page</option>
        </select>
      </div>
    </div>

    <div class="device-table-wrapper hidden" id="deviceTableWrapper">
      <table class="device-table" id="deviceTable">
        <thead>
          <tr>
            <th class="sortable" data-sort="name">
              <div class="th-content">
                <span>Device</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th>QR Code</th>
            <th class="sortable" data-sort="serialNumber">
              <div class="th-content">
                <span>Serial/ID</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th class="sortable" data-sort="type">
              <div class="th-content">
                <span>Type</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th class="sortable" data-sort="category">
              <div class="th-content">
                <span>Category</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th class="sortable" data-sort="status">
              <div class="th-content">
                <span>Status</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th class="sortable" data-sort="holder">
              <div class="th-content">
                <span>Holder/Users</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th class="sortable" data-sort="location">
              <div class="th-content">
                <span>Location/Info</span>
                <span class="sort-indicator"></span>
              </div>
            </th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="deviceTableBody"></tbody>
      </table>
    </div>

    <div class="table-pagination" id="tablePagination"></div>
  </main>

  <!-- QR Code Modal -->
  <div id="qrModal" class="qr-modal">
    <div class="qr-modal-content">
      <div class="qr-modal-header">
        <div>
          <h2 id="qrModalTitle">QR Code</h2>
          <p id="qrModalSubtitle"></p>
        </div>
        <button class="qr-modal-close" onclick="closeQRModal()">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="qr-code-container" id="qrCodeContainer">
        <canvas id="qr-canvas"></canvas>
      </div>
      <p class="qr-modal-hint">Qu√©t QR code ƒë·ªÉ xem th√¥ng tin t√†i s·∫£n</p>
      <div class="qr-modal-actions">
        <button class="qr-action-btn" onclick="downloadQRCode()">
          <i class="fas fa-download"></i>
          <span>T·∫£i xu·ªëng</span>
        </button>
        <button class="qr-action-btn" onclick="printQRCode()">
          <i class="fas fa-print"></i>
          <span>In</span>
        </button>
        <button class="qr-action-btn" onclick="shareQRCode()">
          <i class="fas fa-share-alt"></i>
          <span>Chia s·∫ª</span>
        </button>
      </div>
    </div>
  </div>

  <script src="js/shared.js"></script>
  <script>
    let allDevices = [];
    let filteredDevices = [];
    let sortedDevices = [];
    let paginatedDevices = [];
    
    let originalDevices = [];
    let originalSoftwareAccounts = [];
    
    // Type filter caches
    let allTypes = [];
    let typesByCategory = {};
    
    // Sorting and pagination state
    let currentSort = { column: null, direction: 'asc' };
    let currentPage = 1;
    let pageSize = 30;
    
    // Store debounced functions to allow proper cleanup
    let debouncedFilterDevices = null;
    let debouncedSpecsFilter = null;
    
    async function loadDevices() {
      originalDevices = await AssetFlowUtils.loadJSON('data/devices.json');
      originalSoftwareAccounts = await AssetFlowUtils.loadJSON('data/software-accounts.json');
      
      // Collect all component IDs that are children of other devices
      const componentIdsInChildren = new Set();
      originalDevices.forEach(device => {
        if (device.children && device.children.length > 0) {
          device.children.forEach(child => {
            componentIdsInChildren.add(child.id);
          });
        }
      });
      
      // Build devices with parent-child structure for tree view
      const allItems = [];
      const typeSet = new Set();
      originalDevices.forEach(device => {
        // Check if device has children (it's a container/parent device)
        const hasChildren = device.children && device.children.length > 0;
        
        if (hasChildren) {
          // Add main container device with children info
          allItems.push({ 
            ...device, 
            isComponent: false,
            isParent: true,
            childrenComponents: device.children.map(child => ({
              ...child,
              isComponent: true,
              location: device.location,
              holder: device.holder,
              parentDevice: {
                id: device.id,
                name: device.name,
                serialNumber: device.serialNumber,
                location: device.location,
                holder: device.holder
              }
            }))
          });
          if (device.type) typeSet.add(device.type);
          
          // Also add children as separate items for search/filter (but mark them as children)
          device.children.forEach(child => {
            allItems.push({
              ...child,
              isComponent: true,
              isChild: true,
              parentId: device.id,
              // Inherit location and holder from parent device
              location: device.location,
              holder: device.holder,
              parentDevice: {
                id: device.id,
                name: device.name,
                serialNumber: device.serialNumber,
                location: device.location,
                holder: device.holder
              }
            });
            if (child.type) typeSet.add(child.type);
          });
        } else {
          // Standalone device (not a parent with children)
          // Only add if it's not a child component of another device
          if (!componentIdsInChildren.has(device.id)) {
            allItems.push({ ...device, isComponent: false, isParent: false });
            if (device.type) typeSet.add(device.type);
          }
        }
      });
      
      // Add software accounts
      originalSoftwareAccounts.forEach(account => {
        allItems.push({
          ...account,
          category: 'Software & Licenses',
          isSoftwareAccount: true
        });
        if (account.type) typeSet.add(account.type);
      });
      
      allDevices = allItems;
      filteredDevices = [...allDevices];
      
      // Build type filter caches and initial options
      buildTypeFilterCaches();
      updateTypeFilterOptions('');
      
      // Check for status filter from URL
      const urlParams = new URLSearchParams(window.location.search);
      const statusFilter = urlParams.get('status');
      if (statusFilter) {
        filteredDevices = allDevices.filter(d => d.status === statusFilter);
        const statusFilterEl = document.getElementById('statusFilter');
        const statusDropdown = document.getElementById('statusDropdown');
        if (statusFilterEl) {
          statusFilterEl.value = statusFilter;
        }
        // Update custom dropdown
        if (statusDropdown) {
          const menu = statusDropdown.querySelector('.custom-dropdown-menu');
          const options = menu.querySelectorAll('.custom-dropdown-option');
          const selectedOption = Array.from(options).find(opt => opt.dataset.value === statusFilter);
          if (selectedOption) {
            statusDropdown.querySelector('.custom-dropdown-text').textContent = selectedOption.textContent;
            options.forEach(opt => opt.classList.remove('selected'));
            selectedOption.classList.add('selected');
          }
        }
      }
      
      applySorting();
      renderDevices();
      
      // Initialize event listeners after devices are loaded
      initializeEventListeners();
      initializeSearchInput();
      initializeCustomDropdowns();
    }
    
    // Initialize custom dropdowns
    function initializeCustomDropdowns() {
      // Type Category Dropdown
      const typeCategoryDropdown = document.getElementById('typeCategoryDropdown');
      if (typeCategoryDropdown) {
        const button = typeCategoryDropdown.querySelector('.custom-dropdown-button');
        const menu = typeCategoryDropdown.querySelector('.custom-dropdown-menu');
        const hiddenSelect = typeCategoryDropdown.querySelector('select');
        const options = menu.querySelectorAll('.custom-dropdown-option:not(.disabled)');
        
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.contains('show');
          closeAllDropdowns();
          if (!isOpen) {
            menu.classList.add('show');
            button.classList.add('active');
          }
        });
        
        options.forEach(option => {
          option.addEventListener('click', (e) => {
            e.stopPropagation();
            const value = option.dataset.value || '';
            const text = option.textContent;
            
            // Update button text
            button.querySelector('.custom-dropdown-text').textContent = text;
            
            // Update selected state
            options.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            
            // Update hidden select
            if (hiddenSelect) {
              hiddenSelect.value = value;
              hiddenSelect.dispatchEvent(new Event('change'));
            }
            
            // Close menu
            menu.classList.remove('show');
            button.classList.remove('active');
            
            // Trigger filter
            filterDevices();
          });
        });
      }
      
      // Status Dropdown
      const statusDropdown = document.getElementById('statusDropdown');
      if (statusDropdown) {
        const button = statusDropdown.querySelector('.custom-dropdown-button');
        const menu = statusDropdown.querySelector('.custom-dropdown-menu');
        const hiddenSelect = statusDropdown.querySelector('select');
        const options = menu.querySelectorAll('.custom-dropdown-option');
        
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const isOpen = menu.classList.contains('show');
          closeAllDropdowns();
          if (!isOpen) {
            menu.classList.add('show');
            button.classList.add('active');
          }
        });
        
        options.forEach(option => {
          option.addEventListener('click', (e) => {
            e.stopPropagation();
            const value = option.dataset.value || '';
            const text = option.textContent;
            
            // Update button text
            button.querySelector('.custom-dropdown-text').textContent = text;
            
            // Update selected state
            options.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            
            // Update hidden select
            if (hiddenSelect) {
              hiddenSelect.value = value;
              hiddenSelect.dispatchEvent(new Event('change'));
            }
            
            // Close menu
            menu.classList.remove('show');
            button.classList.remove('active');
            
            // Trigger filter
            filterDevices();
          });
        });
        
        // Set initial selected option based on hidden select
        if (hiddenSelect && hiddenSelect.value) {
          const selectedOption = Array.from(options).find(opt => opt.dataset.value === hiddenSelect.value);
          if (selectedOption) {
            selectedOption.classList.add('selected');
            button.querySelector('.custom-dropdown-text').textContent = selectedOption.textContent;
          }
        }
      }
      
      // Type Dropdown (dynamic options, similar behavior to other custom dropdowns)
      const typeDropdown = document.getElementById('typeDropdown');
      if (typeDropdown) {
        const button = typeDropdown.querySelector('.custom-dropdown-button');
        const menu = typeDropdown.querySelector('.custom-dropdown-menu');
        const hiddenSelect = typeDropdown.querySelector('select');
        
        if (button && menu && hiddenSelect) {
          // Open/close menu
          button.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = menu.classList.contains('show');
            closeAllDropdowns();
            if (!isOpen) {
              menu.classList.add('show');
              button.classList.add('active');
            }
          });
          
          // Delegate click handling to the menu so it works even when options are rebuilt
          menu.addEventListener('click', (e) => {
            const option = e.target.closest('.custom-dropdown-option');
            if (!option) return;
            
            e.stopPropagation();
            const value = option.dataset.value || '';
            const text = option.textContent;
            
            // Update button text
            const textEl = button.querySelector('.custom-dropdown-text');
            if (textEl) {
              textEl.textContent = text;
            }
            
            // Update selected state
            menu.querySelectorAll('.custom-dropdown-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            
            // Update hidden select and trigger change
            hiddenSelect.value = value;
            hiddenSelect.dispatchEvent(new Event('change'));
            
            // Close menu
            menu.classList.remove('show');
            button.classList.remove('active');
            
            // Trigger filter
            filterDevices();
          });
        }
      }
      
      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.custom-dropdown')) {
          closeAllDropdowns();
        }
      });
    }
    
    function closeAllDropdowns() {
      document.querySelectorAll('.custom-dropdown-menu').forEach(menu => {
        menu.classList.remove('show');
      });
      document.querySelectorAll('.custom-dropdown-button').forEach(button => {
        button.classList.remove('active');
      });
    }
    
    // Initialize search input on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeSearchInput);
    } else {
      initializeSearchInput();
    }
    
    function buildTypeFilterCaches() {
      allTypes = [];
      typesByCategory = {};
      
      allDevices.forEach(device => {
        if (!device.type) return;
        const type = device.type;
        const category = (device.category || '').trim();
        
        if (!allTypes.includes(type)) {
          allTypes.push(type);
        }
        
        if (!typesByCategory[category]) {
          typesByCategory[category] = [];
        }
        if (!typesByCategory[category].includes(type)) {
          typesByCategory[category].push(type);
        }
      });
      
      // Sort global type list once
      allTypes.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      Object.keys(typesByCategory).forEach(cat => {
        typesByCategory[cat].sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      });
    }
    
    function updateTypeFilterOptions(selectedCategory = '') {
      const typeFilterEl = document.getElementById('typeFilter');
      const typeDropdown = document.getElementById('typeDropdown');
      if (!typeFilterEl) return;
      
      const previousValue = typeFilterEl.value;
      let sourceTypes = [];
      
      if (selectedCategory && typesByCategory[selectedCategory]) {
        sourceTypes = typesByCategory[selectedCategory];
      } else {
        sourceTypes = allTypes;
      }
      
      // Build native select options
      let selectHtml = '<option value="">All types</option>';
      sourceTypes.forEach(type => {
        selectHtml += `<option value="${type}">${type}</option>`;
      });
      typeFilterEl.innerHTML = selectHtml;
      
      // Restore previous value if still valid
      if (previousValue && sourceTypes.includes(previousValue)) {
        typeFilterEl.value = previousValue;
      } else {
        typeFilterEl.value = '';
      }
      
      // Build custom dropdown menu options to mirror the select
      if (typeDropdown) {
        const menu = typeDropdown.querySelector('.custom-dropdown-menu');
        const buttonTextEl = typeDropdown.querySelector('.custom-dropdown-text');
        if (menu) {
          let menuHtml = '<div class="custom-dropdown-option" data-value="">All types</div>';
          sourceTypes.forEach(type => {
            menuHtml += `<div class="custom-dropdown-option" data-value="${type}">${type}</div>`;
          });
          menu.innerHTML = menuHtml;
          
          // Mark selected option and update button text
          const currentValue = typeFilterEl.value || '';
          const options = menu.querySelectorAll('.custom-dropdown-option');
          let selectedOption = null;
          options.forEach(opt => {
            const isSelected = (opt.dataset.value || '') === currentValue;
            if (isSelected) {
              opt.classList.add('selected');
              selectedOption = opt;
            } else {
              opt.classList.remove('selected');
            }
          });
          
          if (!selectedOption) {
            selectedOption = menu.querySelector('.custom-dropdown-option[data-value=""]');
            if (selectedOption) {
              selectedOption.classList.add('selected');
            }
          }
          
          if (selectedOption && buttonTextEl) {
            buttonTextEl.textContent = selectedOption.textContent;
          }
        }
      }
    }
    
    function filterDevices() {
      const searchTerm = document.getElementById('searchInput')?.value.toLowerCase() || '';
      
      // Advanced filters
      // Get category filter from hidden select or from selected option in custom dropdown
      const typeCategoryDropdown = document.getElementById('typeCategoryDropdown');
      const categoryFilterSelect = document.getElementById('typeCategoryFilter');
      let categoryFilter = '';
      
      // Try to get from hidden select first
      if (categoryFilterSelect) {
        categoryFilter = categoryFilterSelect.value || '';
      }
      
      // If empty, try to get from selected option in custom dropdown
      if (!categoryFilter && typeCategoryDropdown) {
        const selectedOption = typeCategoryDropdown.querySelector('.custom-dropdown-option.selected');
        if (selectedOption && selectedOption.dataset.value) {
          categoryFilter = selectedOption.dataset.value;
        }
      }
      
      // C·∫≠p nh·∫≠t l·∫°i danh s√°ch Type d·ª±a tr√™n Category ƒë√£ ch·ªçn
      updateTypeFilterOptions(categoryFilter.trim());
      
      const typeFilter = document.getElementById('typeFilter')?.value || '';
      const statusFilter = document.getElementById('statusFilter')?.value || '';
      const warrantyFilter = document.getElementById('warrantyFilter')?.value || '';
      const specsFilter = document.getElementById('specsFilter')?.value.toLowerCase() || '';
      
      // Check URL params for status filter
      const urlParams = new URLSearchParams(window.location.search);
      const urlStatusFilter = urlParams.get('status');
      const finalStatusFilter = urlStatusFilter || statusFilter;
      
      filteredDevices = allDevices.filter(device => {
        const isSoftwareAccount = device.isSoftwareAccount || device.category === 'Software & Licenses';
        
        // Basic search - search in name, serial, QR code
        let matchesSearch = !searchTerm;
        if (searchTerm) {
          matchesSearch = 
            device.name.toLowerCase().includes(searchTerm) ||
            (device.serialNumber && device.serialNumber.toLowerCase().includes(searchTerm)) ||
            (device.holder && device.holder.name.toLowerCase().includes(searchTerm));
          
          // Search in assigned users for software accounts
          if (isSoftwareAccount && device.assignedUsers) {
            device.assignedUsers.forEach(user => {
              if (user.name.toLowerCase().includes(searchTerm) || 
                  user.email.toLowerCase().includes(searchTerm)) {
                matchesSearch = true;
              }
            });
          }
          
          // Search in specs
          // if (device.specs) {
          //   const specsString = JSON.stringify(device.specs).toLowerCase();
          //   matchesSearch = matchesSearch || specsString.includes(searchTerm);
          // }
          
          // Search in description for software accounts
          // if (isSoftwareAccount && device.description) {
          //   matchesSearch = matchesSearch || device.description.toLowerCase().includes(searchTerm);
          // }
          
          // Search in provider for software accounts
          if (isSoftwareAccount && device.provider) {
            matchesSearch = matchesSearch || device.provider.toLowerCase().includes(searchTerm);
          }
          
          // Search in parent device info (for components)
          // if (device.parentDevice) {
          //   matchesSearch = matchesSearch || 
          //     device.parentDevice.name.toLowerCase().includes(searchTerm) ||
          //     device.parentDevice.serialNumber.toLowerCase().includes(searchTerm);
          // }
        }
        
        // Category filter - only filter by category (not type)
        // Trim both values to handle any whitespace issues
        const deviceCategory = (device.category || '').trim();
        const filterCategory = categoryFilter.trim();
        const matchesCategory = !filterCategory || deviceCategory === filterCategory;
        
        // Type filter
        const matchesType = !typeFilter || device.type === typeFilter;
        
        // Status filter
        const matchesStatus = !finalStatusFilter || device.status === finalStatusFilter;
        
        // Warranty filter (only for devices with warrantyExpiry, not components or software accounts)
        let matchesWarranty = true;
        if (warrantyFilter && !device.isComponent && !isSoftwareAccount) {
          if (device.warrantyExpiry) {
            const warrantyDate = new Date(device.warrantyExpiry);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            warrantyDate.setHours(0, 0, 0, 0);
            if (warrantyFilter === 'valid') {
              matchesWarranty = warrantyDate >= today;
            } else if (warrantyFilter === 'expired') {
              matchesWarranty = warrantyDate < today;
            }
          } else {
            matchesWarranty = false; // No warranty data
          }
        }
        
        // Specs filter - search for specific specs like "i7", "16GB", "512GB"
        let matchesSpecs = !specsFilter;
        if (specsFilter && device.specs) {
          const specsString = JSON.stringify(device.specs).toLowerCase();
          matchesSpecs = specsString.includes(specsFilter);
        }
        
        return matchesSearch && matchesCategory && matchesType && matchesStatus && matchesWarranty && matchesSpecs;
      });
      
      // Reset to first page when filtering
      currentPage = 1;
      applySorting();
      renderDevices();
    }
    
    function applySorting() {
      sortedDevices = [...filteredDevices];
      
      if (currentSort.column) {
        sortedDevices.sort((a, b) => {
          let aValue, bValue;
          
          switch (currentSort.column) {
            case 'name':
              aValue = a.name || '';
              bValue = b.name || '';
              break;
            case 'serialNumber':
              aValue = a.serialNumber || '';
              bValue = b.serialNumber || '';
              break;
            case 'type':
              aValue = a.type || '';
              bValue = b.type || '';
              break;
            case 'category':
              aValue = a.category || '';
              bValue = b.category || '';
              break;
            case 'status':
              aValue = a.status || '';
              bValue = b.status || '';
              break;
            case 'holder':
              aValue = a.holder ? a.holder.name : '';
              bValue = b.holder ? b.holder.name : '';
              break;
            case 'location':
              aValue = a.location || '';
              bValue = b.location || '';
              break;
            default:
              return 0;
          }
          
          // Handle empty values
          if (!aValue && !bValue) return 0;
          if (!aValue) return 1;
          if (!bValue) return -1;
          
          // Compare values
          if (typeof aValue === 'string' && typeof bValue === 'string') {
            const comparison = aValue.localeCompare(bValue, undefined, { numeric: true, sensitivity: 'base' });
            return currentSort.direction === 'asc' ? comparison : -comparison;
          }
          
          return currentSort.direction === 'asc' 
            ? (aValue > bValue ? 1 : -1)
            : (aValue < bValue ? 1 : -1);
        });
      }
      
      // Apply pagination
      const startIndex = (currentPage - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      paginatedDevices = sortedDevices.slice(startIndex, endIndex);
    }
    
    function sortTable(column) {
      if (currentSort.column === column) {
        // Toggle direction if same column
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        // New column, start with ascending
        currentSort.column = column;
        currentSort.direction = 'asc';
      }
      
      // Update sort indicators
      document.querySelectorAll('.sortable').forEach(th => {
        const indicator = th.querySelector('.sort-indicator');
        if (th.dataset.sort === column) {
          th.classList.add('sorted');
          indicator.textContent = currentSort.direction === 'asc' ? '‚Üë' : '‚Üì';
        } else {
          th.classList.remove('sorted');
          indicator.textContent = '';
        }
      });
      
      applySorting();
      renderDevices();
    }
    
    function changePage(page) {
      currentPage = page;
      applySorting();
      renderDevices();
    }
    
    function changePageSize(size) {
      pageSize = parseInt(size);
      currentPage = 1;
      applySorting();
      renderDevices();
    }
    
    function renderPagination() {
      const totalPages = Math.ceil(sortedDevices.length / pageSize);
      const paginationContainer = document.getElementById('tablePagination');
      
      if (totalPages <= 1) {
        paginationContainer.innerHTML = '';
        return;
      }
      
      let paginationHTML = '<div class="pagination-controls">';
      
      // Previous button
      paginationHTML += `
        <button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">
          ‚Üê Previous
        </button>
      `;
      
      // Page numbers
      const maxVisiblePages = 7;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      
      if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      if (startPage > 1) {
        paginationHTML += `<button class="pagination-btn" onclick="changePage(1)">1</button>`;
        if (startPage > 2) {
          paginationHTML += `<span class="pagination-ellipsis">...</span>`;
        }
      }
      
      for (let i = startPage; i <= endPage; i++) {
        paginationHTML += `
          <button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">
            ${i}
          </button>
        `;
      }
      
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          paginationHTML += `<span class="pagination-ellipsis">...</span>`;
        }
        paginationHTML += `<button class="pagination-btn" onclick="changePage(${totalPages})">${totalPages}</button>`;
      }
      
      // Next button
      paginationHTML += `
        <button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">
          Next ‚Üí
        </button>
      `;
      
      paginationHTML += '</div>';
      
      paginationContainer.innerHTML = paginationHTML;
    }
    
    // Initialize event listeners
    function initializeEventListeners() {
      // Tab filter handlers
      document.querySelectorAll('.filter-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          filterDevices();
        });
      });
      
      // Advanced filter handlers
      const typeCategoryFilter = document.getElementById('typeCategoryFilter');
      const typeFilter = document.getElementById('typeFilter');
      const statusFilter = document.getElementById('statusFilter');
      const warrantyFilter = document.getElementById('warrantyFilter');
      const specsFilter = document.getElementById('specsFilter');
      const clearFiltersBtn = document.getElementById('clearFiltersBtn');
      
      // Create debounced functions
      debouncedFilterDevices = AssetFlowUtils.debounce(filterDevices, 300);
      debouncedSpecsFilter = AssetFlowUtils.debounce(filterDevices, 300);
      
      if (typeCategoryFilter) {
        // Custom dropdowns handle their own events, but keep for compatibility
        typeCategoryFilter.onchange = filterDevices;
      }
      if (typeFilter) {
        typeFilter.onchange = filterDevices;
      }
      if (statusFilter) {
        statusFilter.onchange = filterDevices;
      }
      if (warrantyFilter) {
        warrantyFilter.onchange = filterDevices;
      }
      if (specsFilter) {
        specsFilter.oninput = debouncedSpecsFilter;
      }
      if (clearFiltersBtn) {
        clearFiltersBtn.onclick = clearAllFilters;
      }
    }
    
    function clearAllFilters() {
      document.getElementById('searchInput').value = '';
      document.getElementById('typeCategoryFilter').value = '';
      const typeFilter = document.getElementById('typeFilter');
      if (typeFilter) typeFilter.value = '';
      document.getElementById('statusFilter').value = '';
      document.getElementById('warrantyFilter').value = '';
      document.getElementById('specsFilter').value = '';
      
      // Reset custom dropdowns
      const typeCategoryDropdown = document.getElementById('typeCategoryDropdown');
      if (typeCategoryDropdown) {
        const button = typeCategoryDropdown.querySelector('.custom-dropdown-button');
        const menu = typeCategoryDropdown.querySelector('.custom-dropdown-menu');
        const options = menu.querySelectorAll('.custom-dropdown-option');
        button.querySelector('.custom-dropdown-text').textContent = 'All categories';
        options.forEach(opt => opt.classList.remove('selected'));
        const firstOption = menu.querySelector('.custom-dropdown-option[data-value=""]');
        if (firstOption) firstOption.classList.add('selected');
      }
      
      const statusDropdown = document.getElementById('statusDropdown');
      if (statusDropdown) {
        const button = statusDropdown.querySelector('.custom-dropdown-button');
        const menu = statusDropdown.querySelector('.custom-dropdown-menu');
        const options = menu.querySelectorAll('.custom-dropdown-option');
        button.querySelector('.custom-dropdown-text').textContent = 'All statuses';
        options.forEach(opt => opt.classList.remove('selected'));
        const firstOption = menu.querySelector('.custom-dropdown-option[data-value=""]');
        if (firstOption) firstOption.classList.add('selected');
      }
      
      const typeDropdown = document.getElementById('typeDropdown');
      if (typeDropdown) {
        const button = typeDropdown.querySelector('.custom-dropdown-button');
        const menu = typeDropdown.querySelector('.custom-dropdown-menu');
        const options = menu.querySelectorAll('.custom-dropdown-option');
        if (button) {
          const textEl = button.querySelector('.custom-dropdown-text');
          if (textEl) textEl.textContent = 'All types';
        }
        options.forEach(opt => opt.classList.remove('selected'));
        const firstOption = menu.querySelector('.custom-dropdown-option[data-value=""]');
        if (firstOption) firstOption.classList.add('selected');
      }
      
      // Rebuild type options for "all categories"
      updateTypeFilterOptions('');
      
      filterDevices();
    }
    
    function renderDevices() {
      const isGridView = document.getElementById('gridViewBtn').classList.contains('active');
      
      // Ensure correct view is visible
      if (isGridView) {
        document.getElementById('deviceGrid').classList.remove('hidden');
        document.getElementById('deviceTableWrapper').classList.add('hidden');
        renderGridView();
      } else {
        document.getElementById('deviceGrid').classList.add('hidden');
        document.getElementById('deviceTableWrapper').classList.remove('hidden');
        renderTableView();
      }
    }
    
    function renderGridView() {
      const grid = document.getElementById('deviceGrid');
      grid.innerHTML = '';
      
      if (filteredDevices.length === 0) {
        grid.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üì¶</div>
            <h3>No devices found</h3>
            <p>Try adjusting your search or filters</p>
          </div>
        `;
        return;
      }
      
      filteredDevices.forEach((device, index) => {
        const card = document.createElement('div');
        card.className = 'device-card animate-fade-in';
        card.style.animationDelay = `${index * 0.05}s`;
        
        const isSoftwareAccount = device.isSoftwareAccount || device.category === 'Software & Licenses';
        const location = device.holder ? (device.holder.team || device.location) : device.location;
        const holderName = device.holder ? device.holder.name : null;
        const isComponent = device.isComponent || false;
        const parentInfo = device.parentDevice;
        
        // For software accounts, show license info
        let licenseInfo = '';
        if (isSoftwareAccount && device.totalLicenses !== undefined) {
          const used = device.usedLicenses || 0;
          const total = device.totalLicenses || 0;
          const available = total - used;
          licenseInfo = `
            <div class="device-card-location" style="margin-top: 0.5rem;">
              <span>üìä</span>
              <span>${used}/${total} licenses used (${available} available)</span>
            </div>
          `;
        }
        
        // For software accounts, show assigned users count
        let assignedUsersInfo = '';
        if (isSoftwareAccount && device.assignedUsers && device.assignedUsers.length > 0) {
          assignedUsersInfo = `
            <div class="device-card-holder" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">
              <span>üë•</span>
              <span>${device.assignedUsers.length} user(s) assigned</span>
            </div>
          `;
        }
        
        card.innerHTML = `
          <div class="device-card-image">
            ${isSoftwareAccount ? '<i class="fas fa-key" style="font-size: 2rem; color: var(--primary-color);"></i>' : AssetFlowUtils.getDeviceIcon(device.type)}
            ${isSoftwareAccount ? '<div class="component-badge" style="background: var(--info-color);">Software</div>' : ''}
          </div>
          <div class="device-card-info">
            <div class="device-card-name">${device.name}</div>
            ${isSoftwareAccount && device.provider ? `
              <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                <span>üè¢</span>
                <span>${device.provider}</span>
              </div>
            ` : ''}
            ${isComponent && parentInfo ? `
              <div class="device-card-parent" style="font-size: 0.75rem; color: var(--primary-color); margin-top: 0.25rem;">
                <span>üîó</span>
                <span>Part of: ${parentInfo.name}</span>
              </div>
            ` : ''}
            ${!isSoftwareAccount ? `
              <div class="device-card-location">
                <span>üìç</span>
                <span>${location || 'N/A'}</span>
              </div>
            ` : licenseInfo}
            ${holderName ? `
              <div class="device-card-holder" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">
                <span>üë§</span>
                <span>${holderName}</span>
              </div>
            ` : assignedUsersInfo}
          </div>
          <div class="device-card-controls">
            <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 0.5rem;">
              <span class="status-badge status-${device.status}">${AssetFlowUtils.getStatusDisplayName(device.status)}</span>
              <div style="display: flex; gap: 0.5rem;">
                ${device.qrCode ? `
                  <button class="btn btn-icon btn-secondary" onclick="event.stopPropagation(); showQRCode('${device.qrCode}', '${device.name}', '${device.id}')" style="padding: 0.5rem;" title="Show QR Code">
                    <i class="fas fa-qrcode"></i>
                  </button>
                ` : ''}
                <button class="btn btn-icon btn-secondary" onclick="event.stopPropagation(); viewDevice('${device.id}')" style="padding: 0.5rem;" title="View Details"><i class="fas fa-eye"></i></button>
                <button class="btn btn-icon btn-secondary" onclick="event.stopPropagation(); editDevice('${device.id}')" style="padding: 0.5rem;" title="Edit Device"><i class="fas fa-edit"></i></button>
              </div>
            </div>
          </div>
        `;
        
        card.onclick = (e) => {
          if (!e.target.closest('.device-card-controls') && !e.target.closest('button') && !e.target.closest('input')) {
            const targetId = device.id;
            window.location.href = `device-detail.html?id=${targetId}`;
          }
        };
        
        grid.appendChild(card);
      });
    }
    
    
    function renderTableView() {
      const tbody = document.getElementById('deviceTableBody');
      const tableWrapper = document.getElementById('deviceTableWrapper');
      tbody.innerHTML = '';
      
      // Group devices: separate parents with children from standalone devices
      const parentDevices = [];
      const standaloneDevices = [];
      const processedDeviceIds = new Set();
      
      // Build a map of parent devices and their children from original data
      const parentChildrenMap = new Map();
      originalDevices.forEach(device => {
        if (device.children && device.children.length > 0) {
          parentChildrenMap.set(device.id, device.children);
        }
      });
      
      // Group devices in current page
      paginatedDevices.forEach(device => {
        if (processedDeviceIds.has(device.id)) return;
        
        // Check if this device has children in original data
        const childrenFromOriginal = parentChildrenMap.get(device.id) || [];
        
        // Also check if there are children in filtered list
        const childrenInFiltered = paginatedDevices.filter(d => 
          d.isChild && d.parentId === device.id
        );
        
        const hasChildren = childrenFromOriginal.length > 0 || childrenInFiltered.length > 0;
        
        if (hasChildren) {
          // This is a parent device - use children from original or filtered
          const allChildren = childrenInFiltered.length > 0 
            ? childrenInFiltered 
            : childrenFromOriginal.map(child => ({
              ...child,
              isComponent: true,
              isChild: true,
              parentId: device.id,
              location: device.location,
              holder: device.holder,
              parentDevice: {
                id: device.id,
                name: device.name,
                serialNumber: device.serialNumber,
                location: device.location,
                holder: device.holder
              }
            }));
          
          parentDevices.push({
            ...device,
            isParent: true,
            childrenComponents: allChildren
          });
          
          // Mark children as processed
          allChildren.forEach(child => {
            processedDeviceIds.add(child.id);
          });
        } else if (!device.isChild) {
          // Standalone device (not a child and has no children)
          standaloneDevices.push(device);
        }
        // Skip children devices (they will be rendered with their parent)
      });
      
      // Update table info
      const startIndex = (currentPage - 1) * pageSize + 1;
      const endIndex = Math.min(currentPage * pageSize, sortedDevices.length);
      const totalCount = sortedDevices.length;
      
      document.getElementById('tableInfo').textContent = 
        totalCount === 0 
          ? 'No devices found'
          : `Showing ${startIndex}-${endIndex} of ${totalCount} devices`;
      
      if (paginatedDevices.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="9" class="table-empty">
              <div class="table-empty-icon">üì¶</div>
              <h3>No devices found</h3>
              <p>Try adjusting your search or filters</p>
            </td>
          </tr>
        `;
        renderPagination();
        return;
      }
      
      let rowIndex = 0;
      
      // Render parent devices with children
      parentDevices.forEach((device, parentIndex) => {
        const children = device.childrenComponents || [];
        const hasChildren = children.length > 0;
        
        // Render parent row
        const parentRow = renderDeviceRow(device, rowIndex++, false, hasChildren);
        tbody.appendChild(parentRow);
        
        // Render children rows (hidden by default)
        if (hasChildren) {
          children.forEach((child, childIndex) => {
            const childRow = renderDeviceRow(child, rowIndex++, true, false, device.id);
            childRow.classList.add('tree-child-row');
            childRow.style.display = 'none'; // Hidden by default
            childRow.dataset.parentId = device.id;
            tbody.appendChild(childRow);
          });
        }
      });
      
      // Render standalone devices
      standaloneDevices.forEach((device, index) => {
        const row = renderDeviceRow(device, rowIndex++, false, false);
        tbody.appendChild(row);
      });
      
      // Generate QR codes for all canvas elements
      generateTableQRCodes();
      
      renderPagination();
    }
    
    function generateTableQRCodes() {
      const qrCanvases = document.querySelectorAll('.table-qr-code-canvas');
      qrCanvases.forEach(canvas => {
        const qrCode = canvas.getAttribute('data-qr-code');
        if (qrCode) {
          QRCode.toCanvas(canvas, qrCode, {
            width: 40,
            margin: 1,
            color: {
              dark: "#000000",
              light: "#ffffff"
            }
          }, function (error) {
            if (error) {
              console.error('QR Code generation error:', error);
              canvas.parentElement.innerHTML = '<span style="color: var(--text-secondary); font-size: 0.75rem;">Error</span>';
            }
          });
        }
      });
    }
    
    function renderDeviceRow(device, index, isChild = false, hasChildren = false, parentId = null) {
        const row = document.createElement('tr');
        row.className = 'animate-fade-in';
        row.style.animationDelay = `${index * 0.03}s`;
        const isSoftwareAccount = device.isSoftwareAccount || device.category === 'Software & Licenses';
        const isComponent = device.isComponent || false;
        const parentInfo = device.parentDevice;
        const targetId = device.id;
        
        row.onclick = (e) => {
          // Don't navigate if clicking on action buttons or tree toggle
          if (!e.target.closest('.table-action-btn') && !e.target.closest('.tree-toggle-btn')) {
            window.location.href = `device-detail.html?id=${targetId}`;
          }
        };
        
        const specsText = device.specs ? Object.entries(device.specs).slice(0, 1).map(([k, v]) => `${k}: ${v}`).join(', ') : '';
        
        // For software accounts, show license info
        let licenseInfo = '';
        if (isSoftwareAccount && device.totalLicenses !== undefined) {
          const used = device.usedLicenses || 0;
          const total = device.totalLicenses || 0;
          licenseInfo = `<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">üìä ${used}/${total} licenses</div>`;
        }
        
        // Holder/Users column content logic
        let holderUsersHTML = '<span style="color: var(--text-secondary);">-</span>';
        if (isComponent && parentInfo) {
          // For components, show parent device name
          holderUsersHTML = `
            <div class="table-holder">
              <span class="table-holder-text">${parentInfo.name}</span>
            </div>
          `;
        } else if (isSoftwareAccount) {
          const assigned = Array.isArray(device.assignedUsers) ? device.assignedUsers : [];
          const count = assigned.length;
          const used = (typeof device.usedLicenses === 'number') ? device.usedLicenses : count;
          const total = (typeof device.totalLicenses === 'number') ? device.totalLicenses : Math.max(count, used);
          if (count === 1) {
            holderUsersHTML = `
              <div class="table-holder">
                <span class="table-holder-text">${assigned[0].name}</span>
              </div>
            `;
          } else if (total > 0) {
            holderUsersHTML = `
              <div class="table-holder">
                <span class="table-holder-text">${used}/${total}</span>
              </div>
            `;
          }
        } else if (device.holder && device.holder.name) {
          holderUsersHTML = `
            <div class="table-holder">
              <span class="table-holder-text">${device.holder.name}</span>
            </div>
          `;
        }
        
        const indentClass = isChild ? 'tree-child-indent' : '';
        const arrowIcon = hasChildren 
          ? `<button class="tree-toggle-btn" onclick="event.stopPropagation(); toggleTreeChildren('${targetId}')" title="Toggle children">
               <i class="fas fa-chevron-right tree-arrow-icon"></i>
             </button>`
          : (isChild ? '<span class="tree-spacer"></span>' : '');
        
        row.innerHTML = `
          <td>
            <div class="table-device-info ${indentClass}">
              ${arrowIcon}
              <div class="table-device-icon">${isSoftwareAccount ? '<i class="fas fa-key" style="font-size: 1.5rem; color: var(--primary-color);"></i>' : AssetFlowUtils.getDeviceIcon(device.type)}</div>
              <div class="table-device-details">
                <div class="table-device-name" title="${device.name}">
                  ${device.name}
                  ${isSoftwareAccount ? '<span class="component-badge-inline" style="background: var(--info-color);">Software</span>' : ''}
              </div>
            </div>
          </td>
          <td>
            ${device.qrCode ? `
              <div class="table-qr-code-wrapper" onclick="event.stopPropagation(); showQRCode('${device.qrCode}', '${device.name}', '${device.id}')" title="Click to view QR Code" style="cursor: pointer; display: flex; justify-content: center; align-items: center;">
                <canvas class="table-qr-code-canvas" data-qr-code="${device.qrCode}" style="width: 40px; height: 40px;"></canvas>
              </div>
            ` : `
              <span style="color: var(--text-secondary);">-</span>
            `}
          </td>
          <td>
            <div class="table-serial" title="${device.serialNumber || device.id}">${device.serialNumber || device.id}</div>
          </td>
          <td>
            <div class="table-type">${device.type}</div>
          </td>
          <td>
            <span">${device.category}</span>
          </td>
          <td>
            <span class="status-badge status-${device.status}">${AssetFlowUtils.getStatusDisplayName(device.status)}</span>
          </td>
          <td>
            ${holderUsersHTML}
          </td>
          <td>
            ${!isSoftwareAccount ? `
              <div class="table-location-text">
                ${device.location || 'N/A'}
              </div>
            ` : `
              <div>
                -
              </div>
            `}
          </td>
          <td>
            <div style="display: flex; gap: 0.5rem;">
              <button class="btn btn-icon btn-secondary table-action-btn" onclick="event.stopPropagation(); viewDevice('${targetId}')" title="View Details">
                <i class="fas fa-eye"></i>
              </button>
              <button class="btn btn-icon btn-secondary table-action-btn" onclick="event.stopPropagation(); editDevice('${targetId}')" title="Edit Device">
                <i class="fas fa-edit"></i>
              </button>
              ${device.qrCode ? `
                <button class="btn btn-icon btn-secondary table-action-btn" onclick="event.stopPropagation(); showQRCode('${device.qrCode}', '${device.name}', '${device.id}')" title="Show QR Code">
                  <i class="fas fa-qrcode"></i>
                </button>
              ` : ''}
            </div>
          </td>
        `;
        
        return row;
    }
    
    function toggleTreeChildren(parentId) {
      const childrenRows = document.querySelectorAll(`tr.tree-child-row[data-parent-id="${parentId}"]`);
      const toggleBtn = document.querySelector(`.tree-toggle-btn[onclick*="toggleTreeChildren('${parentId}')"]`);
      const arrowIcon = toggleBtn?.querySelector('.tree-arrow-icon');
      
      if (!toggleBtn || childrenRows.length === 0) return;
      
      const isExpanded = childrenRows[0].style.display !== 'none';
      
      childrenRows.forEach(row => {
        row.style.display = isExpanded ? 'none' : '';
      });
      
      if (arrowIcon) {
        if (isExpanded) {
          arrowIcon.classList.remove('fa-chevron-down');
          arrowIcon.classList.add('fa-chevron-right');
        } else {
          arrowIcon.classList.remove('fa-chevron-right');
          arrowIcon.classList.add('fa-chevron-down');
        }
      }
    }
    
    function viewDevice(id) {
      window.location.href = `device-detail.html?id=${id}`;
    }
    
    function editDevice(id) {
      window.location.href = `device-detail.html?id=${id}`;
    }
    
    // QR Code Modal
    let currentQRData = null;
    
    function showQRCode(qrCode, deviceName, deviceId) {
      currentQRData = { qrCode, deviceName, deviceId };
      
      // Update modal content
      document.getElementById('qrModalTitle').textContent = `QR Code - ${deviceId}`;
      document.getElementById('qrModalSubtitle').textContent = deviceName;
      
      // Clear previous QR code
      const container = document.getElementById('qrCodeContainer');
      container.innerHTML = '<canvas id="qr-canvas"></canvas>';
      
      // Generate QR code
      const canvas = document.getElementById('qr-canvas');
      const text = qrCode;
      
      QRCode.toCanvas(canvas, text, {
        width: 200,
        color: {
          dark: "#000000",
          light: "#ffffff"
        }
      }, function (error) {
        if (error) {
          console.error('QR Code generation error:', error);
          container.innerHTML = `<div style="padding: 2rem; color: var(--text-secondary);">QR Code: ${qrCode}</div>`;
        } else {
          console.log('QR Code generated successfully!');
        }
      });
      
      // Show modal
      document.getElementById('qrModal').classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function closeQRModal() {
      document.getElementById('qrModal').classList.remove('active');
      document.body.style.overflow = '';
      currentQRData = null;
    }
    
    function downloadQRCode() {
      if (!currentQRData) return;
      
      const canvas = document.getElementById('qr-canvas');
      if (!canvas) {
        AssetFlowUtils.showToast('QR code not ready', 'error');
        return;
      }
      
      const link = document.createElement('a');
      link.download = `QR-${currentQRData.deviceId}-${currentQRData.qrCode}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      AssetFlowUtils.showToast('QR code downloaded', 'success');
    }
    
    function printQRCode() {
      if (!currentQRData) return;
      
      const canvas = document.getElementById('qr-canvas');
      if (!canvas) {
        AssetFlowUtils.showToast('QR code not ready', 'error');
        return;
      }
      
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>QR Code - ${currentQRData.deviceId}</title>
            <style>
              body {
                margin: 0;
                padding: 2rem;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-family: Arial, sans-serif;
              }
              h2 {
                margin: 0 0 0.5rem 0;
                font-size: 1.5rem;
              }
              p {
                margin: 0.5rem 0 0 0;
                color: #666;
                font-size: 0.875rem;
              }
              img {
                margin: 1rem 0;
              }
            </style>
          </head>
          <body>
            <h2>QR Code - ${currentQRData.deviceId}</h2>
            <p>${currentQRData.deviceName}</p>
            <img src="${canvas.toDataURL('image/png')}" alt="QR Code">
            <p>Qu√©t QR code ƒë·ªÉ xem th√¥ng tin t√†i s·∫£n</p>
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      setTimeout(() => {
        printWindow.print();
        printWindow.close();
      }, 250);
    }
    
    function shareQRCode() {
      if (!currentQRData) return;
      
      const canvas = document.getElementById('qr-canvas');
      if (!canvas) {
        AssetFlowUtils.showToast('QR code not ready', 'error');
        return;
      }
      
      canvas.toBlob((blob) => {
        if (navigator.share && navigator.canShare) {
          const file = new File([blob], `QR-${currentQRData.deviceId}.png`, { type: 'image/png' });
          if (navigator.canShare({ files: [file] })) {
            navigator.share({
              title: `QR Code - ${currentQRData.deviceId}`,
              text: `${currentQRData.deviceName}`,
              files: [file]
            }).catch(err => {
              if (err.name !== 'AbortError') {
                AssetFlowUtils.showToast('Share failed', 'error');
              }
            });
          } else {
            copyQRToClipboard(canvas);
          }
        } else {
          copyQRToClipboard(canvas);
        }
      }, 'image/png');
    }
    
    function copyQRToClipboard(canvas) {
      canvas.toBlob((blob) => {
        navigator.clipboard.write([
          new ClipboardItem({ 'image/png': blob })
        ]).then(() => {
          AssetFlowUtils.showToast('QR code copied to clipboard', 'success');
        }).catch(() => {
          AssetFlowUtils.showToast('Copy failed', 'error');
        });
      });
    }
    
    // Close modal when clicking outside
    document.getElementById('qrModal')?.addEventListener('click', (e) => {
      if (e.target.id === 'qrModal') {
        closeQRModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const modal = document.getElementById('qrModal');
        if (modal && modal.classList.contains('active')) {
          closeQRModal();
        }
      }
    });
    
    // Initialize search input listener
    function initializeSearchInput() {
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        // Create debounced function if not exists
        if (!debouncedFilterDevices) {
          debouncedFilterDevices = AssetFlowUtils.debounce(filterDevices, 300);
        }
        searchInput.oninput = debouncedFilterDevices;
      }
    }
    
    // Table sorting
    document.querySelectorAll('.sortable').forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.sort;
        sortTable(column);
      });
    });
    
    // Page size change
    document.getElementById('pageSizeSelect')?.addEventListener('change', (e) => {
      changePageSize(e.target.value);
    });
    
    function updateViewMode(isGridView) {
      const gridViewBtn = document.getElementById('gridViewBtn');
      const tableViewBtn = document.getElementById('tableViewBtn');
      const deviceGrid = document.getElementById('deviceGrid');
      const deviceTableWrapper = document.getElementById('deviceTableWrapper');
      const tableControls = document.querySelector('.table-controls');
      const tablePagination = document.getElementById('tablePagination');
      
      if (isGridView) {
        gridViewBtn.classList.add('active');
        tableViewBtn.classList.remove('active');
        deviceGrid.classList.remove('hidden');
        deviceTableWrapper.classList.add('hidden');
        // Hide "Showing ... per page" + pagination in grid view
        if (tableControls) tableControls.style.display = 'none';
        if (tablePagination) tablePagination.style.display = 'none';
        renderGridView();
      } else {
        tableViewBtn.classList.add('active');
        gridViewBtn.classList.remove('active');
        deviceGrid.classList.add('hidden');
        deviceTableWrapper.classList.remove('hidden');
        if (tableControls) tableControls.style.display = 'flex';
        if (tablePagination) tablePagination.style.display = 'flex';
        applySorting();
        renderTableView();
      }
    }
    
    document.getElementById('gridViewBtn').addEventListener('click', () => {
      updateViewMode(true);
    });
    
    document.getElementById('tableViewBtn').addEventListener('click', () => {
      updateViewMode(false);
    });
    
    // Initialize view on page load
    function initializeView() {
      const gridViewBtn = document.getElementById('gridViewBtn');
      const isGridView = gridViewBtn.classList.contains('active');
      updateViewMode(isGridView);
    }
    
    // Initialize view immediately
    initializeView();
    
    // Also initialize after DOM is fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeView);
    }
    
    // Download CSV function
    function downloadCSV() {
      if (filteredDevices.length === 0) {
        AssetFlowUtils.showToast('No devices to export', 'warning');
        return;
      }
      
      // Prepare CSV headers
      const headers = [
        'ID',
        'Name',
        'Serial Number',
        'QR Code',
        'Type',
        'Category',
        'Status',
        'Location',
        'Holder Name',
        'Holder Email',
        'Team',
        'Assigned Date',
        'Purchase Date',
        'Warranty Expiry',
        'Price',
        'Specifications',
        'Provider',
        'License Type',
        'Total Licenses',
        'Used Licenses',
        'Assigned Users',
        'Expiry Date',
        'Description'
      ];
      
      // Convert devices to CSV rows
      const rows = filteredDevices.map(device => {
        const isSoftwareAccount = device.isSoftwareAccount || device.category === 'Software & Licenses';
        const specs = device.specs ? Object.entries(device.specs).map(([k, v]) => `${k}: ${v}`).join('; ') : '';
        const assignedUsers = isSoftwareAccount && device.assignedUsers 
          ? device.assignedUsers.map(u => u.name).join('; ') 
          : '';
        
        return [
          device.id || '',
          device.name || '',
          device.serialNumber || '',
          device.qrCode || '',
          device.type || '',
          device.category || '',
          device.status || '',
          device.location || '',
          device.holder?.name || '',
          device.holder?.email || '',
          device.holder?.team || '',
          device.assignedDate || '',
          device.purchaseDate || '',
          device.warrantyExpiry || '',
          device.price || '',
          specs,
          isSoftwareAccount ? (device.provider || '') : '',
          isSoftwareAccount ? (device.licenseType || '') : '',
          isSoftwareAccount ? (device.totalLicenses || '') : '',
          isSoftwareAccount ? (device.usedLicenses || '') : '',
          assignedUsers,
          isSoftwareAccount ? (device.expiryDate || '') : '',
          isSoftwareAccount ? (device.description || '') : ''
        ];
      });
      
      // Combine headers and rows
      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => {
          // Escape commas and quotes in cell values
          const cellValue = String(cell || '').replace(/"/g, '""');
          return `"${cellValue}"`;
        }).join(','))
      ].join('\n');
      
      // Create blob and download
      const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `devices_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      AssetFlowUtils.showToast(`Exported ${filteredDevices.length} device(s) to CSV`, 'success');
    }
    
    // Load devices on page load
    loadDevices();
  </script>
</body>
</html>

